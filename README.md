# Design-and-implement-friend-recomendation-system-

This project presents a comprehensive Friend Recommendation System developed in Python, designed to replicate the functionality found in modern social networking platforms such as Facebook, LinkedIn, or Twitter. The core of the system is built upon the concept of a graph data structure, where users are represented as nodes and friendships as undirected edges. Using adjacency lists and hash tables, the system efficiently manages user connections, enabling rapid access, insertion, and deletion of relationships. The recommendation engine operates based on two primary algorithms: Mutual Friends Count and Shortest-Path Search. The Mutual Friends method identifies users who share the highest number of common friends with a given user, reflecting a realistic model of how people are often suggested new connections. Meanwhile, the Shortest Path method employs Breadth-First Search (BFS) to locate users at a minimum distance of two or more in the social graph who are not already friends, offering alternate yet relevant recommendations. These recommendations are ranked using a priority queue (heap), allowing the system to return the most relevant top-k results, typically limited to five suggestions per user.

To interact with the system, the project provides two interfaces: a command-line interface (CLI) and a graphical user interface (GUI) using Pythonâ€™s built-in Tkinter library. The GUI offers a user-friendly experience, allowing users to perform all core operations such as adding and deleting users, establishing friendships, requesting recommendations, and exporting results to CSV format with a few clicks. The interface includes entry boxes for user inputs, buttons for various functions, and a scrollable text box to display recommendation results dynamically. The modular code structure includes separate files: `graph.py` for managing graph operations, `recommend.py` for implementing algorithms, `utils.py` for helper functions like CSV export, and `gui.py` for building the user interface. An optional `main.py` file allows users to run the program in CLI mode for environments where a graphical interface is not preferred or available.

This project emphasizes clean code architecture, reusability, and educational value. It introduces and integrates several key computer science concepts such as data structures (graphs, hash tables, heaps), algorithm design (BFS, priority queues), and software design principles like modularity and separation of concerns. The system is designed with scalability in mind and is capable of supporting large social graphs with 10,000 or more nodes, although it is equally suitable for small-scale demonstrations. Exporting recommendations to CSV allows users to analyze results outside the program and supports further extension into analytics or reporting tools. The project also encourages potential future enhancements, such as saving/loading the social graph from disk, visualizing the network with external libraries like NetworkX, or even extending the interface into a web application using Flask or Django.


